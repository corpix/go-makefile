#!/usr/bin/env python3
# The MIT License (MIT)

# Copyright Â© 2015 Dmitry Moskowski

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
from argparse import ArgumentParser
from functools import reduce
from os.path import basename
import sys

package_kind     = "package"
application_kind = "application"
kinds = [
    package_kind,
    application_kind,
]

# Package Makefile parts

package_variables = """
name     := {name}
package  := {host}/{user}/$(name)
"""

package_targets = """
.PHONY: test
test:: dependencies
	go test -v \\
           $(shell glide novendor)

.PHONY: bench
bench:: dependencies
	go test        \\
           -bench=. -v \\
           $(shell glide novendor)

.PHONY: lint
lint:: dependencies
	go vet $(shell glide novendor)
	gometalinter                     \\
		--deadline=5m            \\
		--concurrency=$(numcpus) \\
		$(shell glide novendor)

.PHONY: check
check:: lint test
"""

# Application Makefile parts
# Each application is a package
# (it will include package_variables + package_targets)

application_variables = """
build    := ./build
build_id := {build_id_generator}
ldflags  := -X $(package)/{version_variable}=$(version) \\
            -B $(build_id)
"""

application_targets = """
.PHONY: all
all:: $(name)

.PHONY: $(name)
$(name):: dependencies
	mkdir -p $(build)
	@echo "Build id: $(build_id)"
	go build -a -ldflags "$(ldflags)" -v \\
                 -o build/$(name)            \\
                 $(package)/$(name)

.PHONY: build
build:: $(name)

.PHONY: clean
clean::
	rm -rf $(build)
"""

include = "include {0}"

makefile = """
.DEFAULT_GOAL = all

numcpus  := $(shell cat /proc/cpuinfo | grep '^processor\s*:' | wc -l)
version  := {version_generator}
{package_variables}
{application_variables}

.PHONY: all
all::

.PHONY: tools
tools::
	{tools}

.PHONY: dependencies
dependencies:: tools
	glide install

.PHONY: clean
clean:: tools
	glide cache-clear

{package_targets}

{application_targets}
"""

def indented(l, level=1, prefix="\t", suffix="\n"):
    return (prefix*level).join(
        [v+suffix for v in l]
    )

def format(ctx):
    tools = indented(
        [
            go_get_bin("github.com/Masterminds/glide"),
            go_get_bin("github.com/rogpeppe/godef"),
            go_get_bin("github.com/nsf/gocode"),
            go_get_bin("github.com/alecthomas/gometalinter", ["gometalinter --install"]),
            go_get_src("github.com/stretchr/testify/assert"),
        ] + [go_get_bin(tool) for tool in ctx["tool"]]
    )
    nctx = ctx.copy()
    nctx.update(
        {"tools": tools}
    )

    package = {
        "package_variables": "",
        "package_targets": "",
    }
    if nctx["kind"] == package_kind or nctx["kind"] == application_kind:
        package["package_variables"] = package_variables.format(**nctx).rstrip()
        package["package_targets"]   = package_targets.format(**nctx).rstrip()

    application = {
        "application_variables": "",
        "application_targets": "",
    }
    if nctx["kind"] == application_kind:
        application["application_variables"] = application_variables.format(**nctx).rstrip()
        application["application_targets"]   = application_targets.format(**nctx).rstrip()

    nctx.update(package)
    nctx.update(application)

    return "\n".join(
        reduce(
            # Eliminate two or more empty lines in output
            lambda acc, v: acc+([v] if len(acc) == 0 or acc[-1] != v else []),
            (makefile.format(**nctx).rstrip() + "\n").split("\n"),
            []
        ) + [
            include.format(v)
            for v in nctx["include"]
        ]
    ).strip() + "\n"

def go_get(package, predicate, commands=[]):
    all_commands = [
        "go get {0}".format(package)
    ] + commands

    return """@if [ {predicate} ]; then {commands}; fi""".format(
        predicate=predicate,
        commands=" && ".join(all_commands)
    )

def go_get_src(package, commands=[]):
    return go_get(
        package,
        """! -e "$(GOPATH)"/src/{}""".format(package),
        commands
    )

def go_get_bin(package, commands=[]):
    return go_get(
        package,
        """! -e "$(GOPATH)"/bin/{}""".format(basename(package)),
        commands
    )

def main(args):
    if args["kind"] not in kinds:
        raise KeyError(
            "Unsupported kind '{}', supported kinds are: {}".format(
                args["kind"],
                kinds
            )
        )
    sys.stdout.write(
        format(
            args
        )
    )


if __name__ == "__main__":
    def has_prefix(v, prefix):
        return v == prefix or v.startswith(prefix or "")

    def match(full, part):
        vs = [
            v
            for v in full
            if has_prefix(v, part)
        ]
        if len(vs) == 0:
            return part
        if len(vs) > 1:
            raise RuntimeError(
                "Ambiguous name '{}', did you mean one of these? {}".format(
                    part,
                    vs
                )
            )
        return vs[0]

    def normalize(args):
        nargs = args.copy()
        nargs["kind"] = match(kinds, args["kind"].lower().strip())
        return nargs

    p = ArgumentParser()
    p.add_argument(
        "kind",
        help="Kind of Makefile to generate, should be on of: {}".format(kinds)
    )
    p.add_argument(
        "--name",
        help="Project name to hardcode into the Makefile",
        required=True
    )
    p.add_argument(
        "--host",
        help="Host to hardcode as part of the package url",
        default="github.com"
    )
    p.add_argument(
        "--user",
        help="User to hardcode into the package name as part of url",
        required=True
    )
    p.add_argument(
        "--tool",
        help="List of tools to install in addition to the default",
        nargs="+",
        default=[]
    )
    p.add_argument(
        "--include",
        help="List of other Makefile to include",
        nargs="+",
        default=[]
    )

    #

    p.add_argument(
        "--version-variable",
        help="Version variable name inside your application package",
        default="cli.version"
    )
    p.add_argument(
        "--version-generator",
        help="Version generator code in Make",
        default="$(shell git rev-list --count HEAD).$(shell git rev-parse --short HEAD)"
    )
    p.add_argument(
        "--build-id-generator",
        help="Build ID generator code in Make",
        default="0x$(shell echo $(version) | sha1sum | awk '{print $$1}')"
    )

    #

    main(
        normalize(
            p.parse_args().__dict__
        )
    )
